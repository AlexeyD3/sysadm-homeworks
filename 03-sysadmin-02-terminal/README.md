# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
   > cd являеется встроенной `shell builtin` командой. Если бы она была отдельной программой то для её исполнения создавался бы свой теневой процесс терминала
и выполняясь в нём она бы не приводила к переходу в необходимую директорию в основном окне терминала.
Теоретически, если сделать cd внешней программой, то для смены директории при вызове cd создавался бы новый процесс терминала (с целевой папкой перехода cd),
а старый (из которой был переход) завершался.

2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос.
   > Так как `wc -l` считает количество строк, то мы можем просто вызвать `grep -c <some_string> <some_file>` получив тот же результат.

3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
   > Ответ systemd. Мы можем узнать это воспользовавшись командой ps 1 с выводом: `sbin/init/`, воспользовавшись командой ll обнаружим, что это символьная ссылка на `/lib/systemd/systemd` либо можно использовать команду `pstree 1`

4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?
   > Выполним в терминале pts 0 заведомо ошибочную команду и перенаправим её на pts 1 `ls -l /foldernotfound 2>/dev/pts/1`
     Можем создать дополнительную сессию терминала (pts 1) подключившись к виртуальной машине по ssh ещё раз и при выполнении команды с ошибкой в терминале pts 0 увидим вывод ошибки в терминале pts 1

5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
   > `grep "искомое слово" < file (файл в котором ищем) > result (результат поиска)`

6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
   > если я правильно понял: переключаемся на терминал tty3 (ctrl + alt +F3), а в графическом режиме открываем терминал и вводим `echo LOL >/dev/tty3` и переключившись в tty3 увидим LOL в терминале tty3

7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?
   > `bash 5>&1` создаст файловый дескриптор 5 и перенаправит его вывод в stdout, а `echo netology > /proc/$$/fd/5` направляет выход на созданный дескриптор 5, который в свою очередь перенаправлен на stdout (fd 1) 

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
  > да, получится: `ls -l /nodir 6>&2 2>&1 1>&6 | grep such`

9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?
   > команда выведет переменные окружения без разделения по строкам, точно такой же результат мы получим командой `env | xargs echo -n` или просто `env` с построчным разделением

10. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.
  > `/proc/<PID>/cmdline` выведет команду, к которой относится
  > `/proc/<PID>/exe` это символьная ссылка на путь к исполняемому файлу, из которого вызвана программа с этим PID

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.
  > sse4_2 `grep -i SSE /proc/cpuinfo` или отсекая лишний текст `grep -io SSE[0-9_]* /proc/cpuinfo`

12. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:

    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
	not a tty
    ```
`Почитайте, почему так происходит, и как изменить поведение.`

   > При отправке команды через ssh не выделяется новый псевдотерминал, т.к. sshd и так поймёт и выполнит отправленную команду.
   > Можно использовать флаг `-t для принудительного выделения псевдо-терминала`. Это так же может быть использовано для произвольного выполнения программ базирующихся на выводе изображения на удаленной машине, например, при реализации возможностей меню.

	
13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.
  > пока не разобрался

14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.
  > команда `tee` осуществляет вывод в терминал и в файл, указаный в качестве параметра, и в `stdout`, 
в `echo string | sudo tee /root/new_file` команда получает вывод из `stdin`, перенаправленный через `pipe` от `stdout` команды `echo`
а так как команда запущена с правами `sudo` соотвественно имеет права на запись в файл

 
